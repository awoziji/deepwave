# AUTOGENERATED! DO NOT EDIT! File to edit: 00_preprocessing.ipynb (unless otherwise specified).

__all__ = ['check_files', 'Labels', 'get_freq_from_file', 'change_data_frequency', 'split_data', 'load_data_one_file',
           'load_data_list', 'load_data_folder', 'plot_data', '__binary_search', 'binary_search', 'get_window_range',
           'plot_window', 'plot_all_windows', 'TimeSerie']

# Cell
def check_files(folder_path, station="B2DF", channel="001"):
    freq_setted = False
    freq = -1
    data_list = list()
    f_ok = 0
    f_fail = 0

    for idx, file_path in enumerate(folder_path.glob("**/*")):
        try:
            print(f"File #{idx + 1}: {file_path.name}")
            try:
                data = TimeSerie.load_data_one_file(file_path, station, channel)
            except Exception as e:
                print(e)
                print (f"File: {file_path.name} is not in miniseed format.")
            if not freq_setted:
                freq = data['freq']
            else:
                assert data['freq'] == freq, \
                        f"La frecuencia de las mediciones en los datos es de {data['freq']} \
                        pero se espera una frecuencia igual a {freq}"
            assert 3590 < data['end']-data['start'] < 3600, \
                    f"El archivo debe tener 1 hora de mediciones."
            assert data['freq']*(data['end']-data['start'])+1 == len(data['data']), \
                    f"La cantidad de muestras en los datos no coincide con la frecuencia y tiempo en que se tomaron."
            print(f"File OK!!!")
            f_ok += 1
        except Exception as e:
            print(e)
            print(f"############# File FAILED #############")
            f_fail += 1
    print(f"Files OK: {f_ok} | Files FAILED: {f_fail}")

# Cell

class Labels:
    def __init__(self,labels_path):
        labels_path = Path(labels_path)
        self.data = pd.read_csv(labels_path, sep='|', index_col=None)
        self.lbl_reg_exp = re.compile(r"\d+.0\s+Hz,.+(?P<clase>(bt|vt|bf|lp|a1|tr|hb)).+", flags = re.IGNORECASE)
        self.__clean_labels()

    def __clean_labels(self):
        # Eliminar las filas que les falte algun dato
        self.data.dropna(inplace = True)

        # Eliminar los espacios al inicio y final en cada elemento
        self.data = self.data.applymap(lambda x: x.strip())

        # Nuevo DataFrame con dos columnas:
        # la primera es el tiempo inicial y la segunda el el tiempo final
        tmp = self.data["tiempo"].str.split(" - ", n = 1, expand = True)

        # la primera columna se copia al DataFrame inicial con el nombre "tiempo_inicio".
        # Ademas,se elimina la z del final de la fecha, para que funcione el parseo a fecha en obspy.
        self.data["tiempo_inicio"]= tmp[0].str.strip("[zZ]")

        # la segunda columna se copia al DataFrame inicial con el nombre "tiempo_inicio".
        # Ademas,se elimina la z del final de la fecha, para que funcione el parseo a fecha en obspy.
        self.data["tiempo_final"]= tmp[1].str.strip("[zZ]")

        # Se elimina la antigua columna que tenia ambas fechas mezcladas.
        self.data.drop(columns  =["tiempo"], inplace = True)

        self.data["clase"] = self.data["clase"].apply(lambda x: self.lbl_reg_exp.match(x).group("clase").lower())

        self.data["tiempo_inicio"] = self.data["tiempo_inicio"].apply(op.UTCDateTime)
        self.data["tiempo_final"] = self.data["tiempo_final"].apply(op.UTCDateTime)

    def __repr__(self):
        return str(self.data.head())

# Cell

def get_freq_from_file(file_path, station="B2DF", channel="001"):
    st = read(str(file_path))
    for tr in st:
        if tr.stats.station == station and tr.stats.channel == channel:
            return tr.stats.sampling_rate

# Cell

def change_data_frequency(data, initial_freq, final_freq):
    rate = int(initial_freq / final_freq)
    data = data[::rate]
    return data

# Cell

def split_data(data, window_size, step):
    "Recibe un arreglo y lo divide en una matriz utilizando el tamaño de ventana y de paso definidos."
    assert window_size > 0, "El tamaño de paso debe ser mayor que 0."
    assert step > 0, "El tamaño de paso debe ser mayor que 0."
    return np.array([
                        data[i * step: i * step + window_size]
                        for i in range((len(data) - window_size) // step + 1)
                    ])

# Cell

def load_data_one_file(file_path, freq = 500, station="B2DF", channel="001"):
    """
    Busca en el camino del archivo pasado por parametros y
    retorna un diccionario con la fecha de inicio y termino,
    ademas de los datos correspondientes a la estacion y el canal pasados por parametros.
    """

    file_path = str(file_path)

    st = read(file_path)
    for tr in st:
        if tr.stats.station == station and tr.stats.channel == channel:
            data = change_data_frequency(tr.data, tr.stats.sampling_rate, ts.freq)
            return {"start": tr.stats.starttime, "end": tr.stats.endtime,
                    "data": data, "freq": ts.freq}

def load_data_list(list_file_path, station="B2DF", channel="001", freq=500):
    """
    Busca en cada camino de archivo de la lista pasado por parametros y
    retorna una lista de diccionarios con las fecha de inicio y termino,
    ademas de los datos correspondientes a la estacion y el canal pasados por parametros.
    """
    data = [
             load_data_one_file(file_path, station, channel) \
             for file_path in list_file_path \
             if not file_path.is_dir()
           ]
    return data

def load_data_folder(folder_path, station="B2DF", channel="001", freq=500):
        """
        Busca en cada archivo miniseed del directorio pasado por parametros y
        retorna una lista de diccionarios con las fecha de inicio y termino,
        ademas de los datos correspondientes a la estacion y el canal pasados por parametros.
        """
        data = load_data_list(folder_path.glob("**/*"), station, channel)
        return data

# Cell

def plot_data(x_data, y_data, color, label):
    sns.lineplot(x = x_data, y = y_data, color=color, label=label)

# Cell

def __binary_search(item, data, ini, fin):
    if ini >= fin:
        if data[ini] > item: return ini-1
        return ini

    med = (ini + fin)//2
    if data[med] == item: return med

    if (data[med] > item):
        return __binary_search(item, data, ini, med-1)
    else:
        return __binary_search(item, data, med+1, fin)

def binary_search(item, data):
    return __binary_search(item, data, 0, len(data)-1)

# Cell

def get_window_range(ts, label, file_pos):
    "Devuelve las ventanas donde empieza y termina el sismo"

    # Se calcula los segundos del archivo en que comienza y termina el sismo
    sec_sta = label['tiempo_inicio'] - ts.dates[file_pos]
    sec_end = label['tiempo_final'] - ts.dates[file_pos]

    # En base a los segundos donde empieza y termina el sismo,
    # se calcula la ventana inicial y final del sismo
    win_sta = sec_sta // ts.step
    win_end = sec_end // ts.step

    return win_sta, win_end

# Cell

def plot_window(ts, label, file_pos, win_pos):
    ""
    # Se cargan los datos del archivo donde se encuentra el sismo.
    data = load_data_one_file(ts.data[file_pos], freq=ts.freq)

    window_sta = int(win_pos * ts.step * ts.freq)
    window_end = int((win_pos * ts.step + ts.window_size) * ts.freq)

    y_data = data['data'][window_sta:window_end]
    window_data_size = ts.window_size * ts.freq
    x_data = np.linspace(0, window_data_size - 1, window_data_size)
    #plt.plot(y_data, color="black", label="Normal")
    plot_data(ts.x_data, y_data, "black", "Normal")

    # Se calcula los segundos del archivo en que comienza y termina el sismo
    sec_sta = label['tiempo_inicio'] - ts.dates[file_pos]
    sec_end = label['tiempo_final'] - ts.dates[file_pos]

    # Se calcula donde comienza con respecto a la ventana
    sis_sta = max(0, int(sec_sta * ts.freq) - window_sta)
    sis_end = max(0, int(sec_end * ts.freq) - window_sta)

    y_data = y_data[sis_sta:sis_end]
    x_data = x_data[sis_sta:sis_end]

    plot_data(x_data, y_data, "blue", "Sismo")
    plt.show()

# Cell

def plot_all_windows(ts, label):
    file_pos, tmp = ts.label_files[label_pos]
    if file_pos == tmp and file_pos != -1:
        win_sta, win_end = get_window_range(ts, label, file_pos)
    for window_pos in range(int(win_sta), int(win_end)):
        plt.clf()
        plt.axis(ymin=-30000, ymax=30000)
        plot_window(ts, label, file_pos, window_pos)

# Cell

class TimeSerie:
    "Estructura de datos que almacena las mediciones en una estacion."

    def __init__(self, folder_path, labels:Labels=None, window_size:str="2m", step:str="30s"):
        "El formato de `window_size` y `step` es \d+[smh]"
        "`window_size` representa el tamaño de tiempo en que sera cortada la serie de tiempo"
        "`step` representa el tamaño de paso que se utiliza al cortar la serie de tiempo"
        "`freq` es la frecuencia en Hz que tienen las mediciones"

        self.window_size = self.__process_time(window_size)
        self.step = self.__process_time(step)

        self.data = self.__get_internal_data(Path(folder_path))
        self.dates = self.__extract_dates(self.data)
        dates_tmp, data_tmp = zip(*sorted(zip(self.dates, self.data)))
        self.data = list(data_tmp)
        self.dates = list(dates_tmp)

        self.labels = labels
        if labels:
            self.label_files =[self.__get_label_files(label['tiempo_inicio'], label['tiempo_final'])
                               for _, label in labels.data.iterrows()]

        self.windows_x_file = ((3590 - self.window_size) // self.step) + 1

    def __get_internal_data(self, folder_path, station="B2DF", channel="001"):
        freq_setted = False
        data = list(folder_path.glob("**/*"))

        for file_path in data:
            try:
                self.freq = get_freq_from_file(file_path, station, channel)
                self.original_freq = self.freq
                break
            except:
                print (f"File: {file_path.name} is not in miniseed format.")

        return data

    def __extract_dates(self, data):
        reg_exp = re.compile(r"(?P<year>(\d{4}))-(?P<month>(\d{2}))-(?P<day>(\d{2}))-(?P<hour>(\d{2}))(?P<min>(\d{2}))-\d+M\..+",
                         flags = re.IGNORECASE)
        def transform(item):
            match = reg_exp.match(item.name)
            return op.UTCDateTime(int(match.group('year')), int(match.group('month')), int(match.group('day')),
                                  int(match.group('hour')), int(match.group('min')))

        return list(map(transform, data))

    def __get_label_files(self, ini_date, end_date):
        ini_file = binary_search(ini_date, self.dates)
        end_file = binary_search(end_date, self.dates)
        return ini_file, end_file

    @staticmethod
    def __process_time(time):
        match = re.match(r"(?P<val>\d+)(?P<smh>[smh]*)$", time, re.I)
        assert match, "Formato incorrecto de tamaño de ventana o paso."

        result = int(match.group("val"))
        if match.group("smh").lower() == "m":
            result *= 60
        elif match.group("smh").lower() == "h":
            result *= 60*60
        return result

    def change_frequency(self, new_freq:int):
        assert type(new_freq) is int, "La frecuencia debe ser un entero."
        assert new_freq > 0 and new_freq <= 500, "La frecuencia debe definirse entre 1 y 500 Hz"
        assert new_freq <= self.original_freq, \
                f"La nueva frecuencia: {new_freq} debe ser menor que la original: {self.original_freq}."
        self.freq = new_freq

    def __getitem__(self, idx):
        file_idx = idx // self.windows_x_file
        window_idx = idx % self.windows_x_file

        file_path = self.data[file_idx]
        data = load_data_one_file(file_path)

        data_idx = int(window_idx*self.freq*self.step)

        tmp_data = data['data'][data_idx : int(data_idx + self.window_size * self.freq)]
        tmp_data = change_data_frequency(tmp_data, data['freq'], self.freq)

        return {"start": data['start'] + window_idx * self.step,
                "end": data['start'] + window_idx * self.step + self.window_size,
                "data": tmp_data,
                "freq": self.freq}

    def __repr__(self):
        return f"window_size {self.window_size}\nstep {self.step}\nfreq {self.freq}"

    def __str__(self):
        return f"window_size {self.window_size}\nstep {self.step}\nfreq {self.freq}"